#!/bin/busybox ash
# Check https://github.com/jumperfly/initramfs-overlay/blob/master/src/init

#!/bin/ash

safeboot="/overlay_root/.safeboot"
ubootlog="/boot_root/boot/uboot.log"

do_splash() {
    img="$1"
    for fbdev in /dev/fb[0-9]; do
        [ -e "$fbdev" ] || break
        fbsplash -s "${img}" -d "$fbdev"
    done
}

check_safeboot() {
    if test -e "${safeboot}" ; then
        safebootvalue=`cat "${safeboot}"`
        let safebootvalue++
            if test "${safebootvalue}" -gt 3 ; then
            return 1
        else
            echo "${safebootvalue}" > "${safeboot}"
        fi
    else
        echo "0" > "${safeboot}"
    fi
    sync
    return 0
}

check_update() {
    # All update files?
    mkdir -p /boot_root/update/
    if [ -f /boot_root/update/boot.lst ]; then
      while read -r file; do
        if [ ! -f "/boot_root/update/$file" ]; then
          return 1
        fi
      done < /boot_root/update/boot.lst
      return 0
    fi
    return 1
}

do_clean_overlay() {
    # backup and clean up overlay
    rm -rf /overlay_root/upper.old
    mv /overlay_root/upper /overlay_root/upper.old
    mkdir -p /overlay_root/upper
}

do_clean_case() {
    # clear case setting
    sed -i -E 's/^case=(.+):1/case=\1/' /boot_root/recalbox-boot.conf
}

do_clean_safeboot() {
    echo "0" > "${safeboot}"
}

do_update() {
    # UPDATE!
    if [ -f /boot_root/update/boot.lst ]; then
      # filelist mode
      while read -r file; do
        [ ! -d `dirname "/boot_root/$file"` ] && mkdir -p `dirname "/boot_root/$file"`
        mv "/boot_root/update/$file" "/boot_root/$file" || return 1
      done < /boot_root/update/boot.lst
      rm /boot_root/update/boot.lst
    fi
    # delete content of /boot_root/update/
    rm -rf /boot_root/update/
    mkdir /boot_root/update/

    # remove useless files
    rm /boot_root/boot.lst
    rm /boot_root/pre-upgrade.sh
}

get_boot_device() {
    # return /dev entry which is mounted under /boot_root
    mount >&2
    part=$(mount | sed '/\/boot_root/!d;s/\son\s*.*//')
    part=${part#/dev/}
    disk=$(readlink /sys/class/block/$part)
    disk=$(dirname $disk)
    disk=/dev/$(basename $disk)
    echo $disk
}

do_flash() {
    # flash uboot:
    # $1 file name to flash
    # $2 device where to flash
    # $3 sector where to flash
    echo "will flash $1 on $2 at sector $3"
    dd if="$1" of="$2" conv=notrunc seek="$3"
}

do_uboot_update() {
    echo "==========================="
    boot_device=$(get_boot_device)
    if [ -z "$boot_device" ]; then
        echo "boot device not found..." >&2
        return 1
    fi

    echo "boot_device=$boot_device"

    find /boot_root/boot/uboot -type f | while read -r file; do
      echo "found $file"
      sector_dir=$(dirname $file)
      sector=$(basename $sector_dir)
      do_flash "$file" "$boot_device" "$sector"
      rm -rf "$sector_dir"
    done
}

do_root() {
    mkdir -p /boot_root /new_root /overlay_root /sys /proc || return 1
    mount -t proc  -o nodev,noexec,nosuid proc  /proc || return 1
    mount -t sysfs -o nodev,noexec,nosuid sysfs /sys || return 1

    # read the parameters
    read -r cmdline < /proc/cmdline
    for param in ${cmdline} ; do
        case ${param} in
            dev=*)   dev=${param#dev=};;
            label=*) label=${param#label=};;
        esac
    done

    # look for devices
    mount -t devtmpfs none /dev

    toMount="LABEL=RECALBOX"
    isDevice="0"
    test -n "${dev}"   && toMount=${dev} && isDevice="1"
    test -n "${label}" && toMount=LABEL=${label}

    # Wait for boot mount to be ready
    timeout=0
    while ! mount -t vfat -o rw ${toMount} /boot_root ; do
        echo "Waiting for the root device"
        sleep 1
    done

    # Background display for supported devices
    # eg: gpicase
    test -e /boot_root/boot.ppm && do_splash /boot_root/boot.ppm

    # update
    updated="0"
    if check_update ; then
        if ! do_update ; then return 1; fi
        updated="1"
        [ -d /boot_root/boot/uboot ] && do_uboot_update >>$ubootlog 2>&1
    fi

    # Get overlay mount
    overlayToMount="LABEL=OVERLAY"
    if test "$isDevice" -eq "1" ; then
        deviceLength=$((${#toMount}-1))
        overlayToMount=${toMount:0:$deviceLength}$((${toMount:$deviceLength}+2))
    fi

    # Mount overlay partition
    if ! mount -o rw ${overlayToMount} /overlay_root ; then
        # Partition not available: Mount tmpfs partition
        mount -t tmpfs -o size=128M tmpfs /overlay_root || return 1
    fi
    # Backup, clean up overlay, clean up case setting and reboot
    if test "$updated" -eq "1" ; then
        do_clean_overlay
        do_clean_case
        do_clean_safeboot
        umount /boot_root
        umount /overlay_root
        sync
        reboot -f
    fi

    # Clean overlay and case setting after 3 unsuccessfull boot attempts
    if ! check_safeboot ; then
        do_clean_overlay
        do_clean_case
        do_clean_safeboot
    fi

    # Create overlay folders and user video folder
    mkdir -p /overlay_root/lower /overlay_root/upper /overlay_root/work /overlay_root/bootvideos /overlay_root/dropbear \
             /overlay_root/.configs || return 1

    # write protect boot device
    mount -o remount,ro /boot_root || return 1

    # Mount the squashfs as overlay "lower" file-system
    mount /boot_root/boot/recalbox /overlay_root/lower || return 1

    # Mount the future root in read write
    if ! mount -t overlay overlay -o ro,lowerdir=/overlay_root/lower,upperdir=/overlay_root/upper,workdir=/overlay_root/work /new_root ; then
        # Mount squashfs as new root when overlayfs is not supported
        mount /boot_root/boot/recalbox /new_root || return 1
    fi

    # moving current mounts
    mount --move /boot_root    /new_root/boot    || return 1
    mount --move /overlay_root /new_root/overlay || return 1
    mount --move /sys          /new_root/sys     || return 1
    mount --move /proc         /new_root/proc    || return 1
    mount --move /dev          /new_root/dev     || return 1

    # switch to the new root
    exec switch_root /new_root /sbin/init || return 1
}

if ! do_root
then
    echo "Recalbox cannot boot at initramfs stage. Please contact support!"
    /bin/ash
fi
